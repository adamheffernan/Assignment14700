<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- saved from url=(0079)file:///C:/Users/Adam/Documents/4700Github/Assignment14700/html/MonteCarlo.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>MonteCarlo</title><meta name="generator" content="MATLAB 9.7"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-02-02"><meta name="DC.source" content="MonteCarlo.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="comment">%%Adam Heffernan 100977570 Assignment 1 ELEC 4700. Completed on 2/1/2020.</span>

clc
close <span class="string">all</span>

m_0 = 9.10938e-31; <span class="comment">%Mass of Electron</span>
m = 0.26*m_0;<span class="comment">%Effective mass in silicon</span>
T = 300;<span class="comment">%temperature in Kelvin</span>
k = 1.38064e-23;<span class="comment">%Boltzmans Constant</span>
v_th = sqrt((2*k*T)/m); <span class="comment">%Thermal velocity of particles</span>
mean = 0.2e-12;<span class="comment">%Mean value</span>
width = 100e-9;<span class="comment">%Width of Wafer</span>
length = 200e-9;<span class="comment">%Length of the channel</span>
par = 10000;<span class="comment">%Particles</span>
pop = 10; <span class="comment">%Mapping population</span>
iter = 200;<span class="comment">%Iterations</span>
pos_velo = zeros(par,4);<span class="comment">%Initializing position velocity Matrix</span>
temp = zeros(iter,1);<span class="comment">%Initializing position velocity Matrix</span>
traj = zeros(iter, 2*pop);<span class="comment">%Initializing trajectory Matrix</span>
step = width/v_th/100;<span class="comment">%Calculating step size for the movement of particles</span>
boundaries_len = false(1); <span class="comment">%Either diffusive or specular boundaries true for specular false for diffusive</span>
boundaries_width = false(1);<span class="comment">%Either diffusive or specular boundaries true for specular false for diffusive</span>
total_scatters = 0;
<span class="comment">%Calculating mean free path for part 1</span>
l=v_th*mean;
<span class="comment">%Outputting mean free path and thermal velocity for part 1</span>
fprintf(<span class="string">'Thermal Velocity for part 1 is %f km/s\n'</span>,v_th/10^3)
fprintf(<span class="string">'Mean free path for part 1 is %f nm\n'</span>,l/10^-9);
<span class="comment">%%Question 1</span>
<span class="keyword">for</span> j = 1:par
    <span class="comment">%Creating a position, velocity vector in the x and y directions for</span>
    <span class="comment">%the number of particles in the simulation.</span>
    ang = rand*2*pi;
    pos_velo(j,:) = [length*rand width*rand v_th*cos(ang) v_th*sin(ang)];
<span class="keyword">end</span>

<span class="keyword">for</span> j = 1:iter
    <span class="comment">%Updating the position velocity vector at each iteration. Using step</span>
    <span class="comment">%size * position velocity vector of each particle at each iteration in</span>
    <span class="comment">%time plus the previous X and Y locations of the particle respectively.</span>
    <span class="comment">%</span>
    pos_velo(:,1:2) = pos_velo(:,1:2) + step*pos_velo(:,3:4);
    <span class="comment">%</span>
    <span class="comment">%Left Bound Check</span>
    i = pos_velo(:,1) &gt; length;
    pos_velo(i,1) = pos_velo(i,1) - length;
    <span class="comment">%</span>
    <span class="comment">%Right Bound Check</span>
    <span class="comment">%</span>
    i = pos_velo(:,1) &lt; 0;
    pos_velo(i,1) = pos_velo(i,1) + length;
    <span class="comment">%</span>
    <span class="comment">%Top Bound Check</span>
    i = pos_velo(:,2) &gt; width;
    pos_velo(i,2) = 2*width - pos_velo(i,2);
    pos_velo(i,4) = -pos_velo(i,4);
    <span class="comment">%</span>
    <span class="comment">%Bottom Bound Check</span>
    i = pos_velo(:,2) &lt; 0;
    pos_velo(i,2) = -pos_velo(i,2);
    pos_velo(i,4) = -pos_velo(i,4);
    <span class="comment">%</span>
    <span class="comment">%Storing the Temperature value of the semiconductor at each iteration</span>
    temp(j) = (sum(pos_velo(:,3).^2) + sum(pos_velo(:,4).^2))*m/k/2/par;
    <span class="comment">%Storing the Trajectory value of the semiconductor at each iteration</span>
    traj(1:iter,2*j:2*j+1) = [pos_velo(1:iter,1) pos_velo(1:iter,2)];
    figure(1);
    subplot(2,1,1)
    <span class="comment">%Plotting each particle in the population at each time step</span>
    plot(pos_velo(1:pop,1)./1e-9, pos_velo(1:pop,2)./1e-9, <span class="string">'o'</span>);
    axis([0 length/1e-9 0 width/1e-9]);
    title(<span class="string">'Simulation of Electrons in Silicon Crystal'</span>)
    xlabel(<span class="string">'(nm)'</span>)
    ylabel(<span class="string">'(nm)'</span>)
    subplot(2,1,2)
    <span class="comment">%Plotting the temperature of the Silicon crystal over time</span>
    plot(step*(0:j-1), temp(1:j),<span class="string">'Color'</span>,[0.1 0.1 0.1]);
    axis([0 step*iter 200 400]);
    title(<span class="string">'Temperature of Electrons in Silicon Crystal'</span>)
    xlabel(<span class="string">'Time(s)'</span>)
    ylabel(<span class="string">'Temperature(K)'</span>)
    hold <span class="string">on</span>;
<span class="keyword">end</span>


<span class="keyword">for</span> i = 1:pop

    <span class="comment">%Setting a Random colour each particle</span>
    color = [rand rand rand];
    figure(2)
    <span class="comment">%Plotting the trajectory vector of each particle in the shown</span>
    <span class="comment">%population</span>
    plot(traj(i,2:2:end)./1e-9, traj(i,1:2:end-1)./1e-9, <span class="string">'.'</span>, <span class="string">'Color'</span>,color);
    axis([0 length/1e-9 0 width/1e-9]);
    title(<span class="string">'Trajectories of Electrons in Silicon Crystal'</span>)
    xlabel(<span class="string">'(nm)'</span>)
    ylabel(<span class="string">'(nm)'</span>)
    hold <span class="string">on</span>;
    pause(0.5);

<span class="keyword">end</span>
<span class="comment">%%Question 2</span>
<span class="comment">%Calculating the probability of a scattering particle</span>
scat = 1 - exp(-step/mean);
<span class="comment">%Calculating a normal maxwell-boltzmann distribution</span>
v_boltz = makedist(<span class="string">'Normal'</span>,<span class="string">'mu'</span>,0,<span class="string">'sigma'</span>,sqrt(k*T/m));

<span class="keyword">for</span> j = 1:par
    <span class="comment">%Creating a position, velocity vector in the x and y directions for</span>
    <span class="comment">%the number of particles in the simulation.</span>
    ang = rand*2*pi;
    pos_velo(j,:) = [length*rand width*rand random(v_boltz) random(v_boltz)];
<span class="keyword">end</span>


<span class="keyword">for</span> j = 1:iter
    <span class="comment">%Updating the position velocity vector at each iteration. Using step</span>
    <span class="comment">%size * position velocity vector of each particle at each iteration in</span>
    <span class="comment">%time plus the previous X and Y locations of the particle respectively.</span>
    <span class="comment">%</span>
    pos_velo(:,1:2) = pos_velo(:,1:2) + step*pos_velo(:,3:4);
    <span class="comment">%</span>
    <span class="comment">%Left Bound Check</span>
    <span class="comment">%</span>
    i = pos_velo(:,1) &gt; length;
    pos_velo(i,1) = pos_velo(i,1) - length;
    <span class="comment">%</span>
    <span class="comment">%Right Bound Check</span>
    <span class="comment">%</span>
    i = pos_velo(:,1) &lt; 0;
    pos_velo(i,1) = pos_velo(i,1) + length;
    <span class="comment">%</span>
    <span class="comment">%Top Bound check</span>
    <span class="comment">%</span>
    i = pos_velo(:,2) &gt; width;
    pos_velo(i,2) = 2*width - pos_velo(i,2);
    pos_velo(i,4) = -pos_velo(i,4);
    <span class="comment">%</span>
    <span class="comment">%Bottom Bound check</span>
    <span class="comment">%</span>
    i = pos_velo(:,2) &lt; 0;
    pos_velo(i,2) = -pos_velo(i,2);
    pos_velo(i,4) = -pos_velo(i,4);
    <span class="comment">%Creating a random number t for each particle in the population that is</span>
    <span class="comment">%the probability of this particle scattering at this time iteration</span>
    t=rand(pop,1);
    <span class="comment">%Setting i equal to a logical index array with the amount of colisions.</span>
    i= t &lt; scat;
    pos_velo(i,3:4) = random(v_boltz, [sum(i),2]);
    <span class="comment">%Incrementing the total number of scattered particles</span>
    total_scatters = total_scatters + count_scatters(i);
    <span class="comment">%Storing the Temperature value of the semiconductor at each iteration</span>
    temp(j) = (sum(pos_velo(:,3).^2) + sum(pos_velo(:,4).^2))*m/k/2/par;
    <span class="comment">%Storing the Trajectory value of the semiconductor at each iteration</span>
    traj(1:iter,2*j:2*j+1) = [pos_velo(1:iter,1) pos_velo(1:iter,2)];
    figure(3)
    subplot(3,1,1)
    <span class="comment">%Plotting each particle in the population at each time step</span>
    plot(pos_velo(1:pop,1)./1e-9, pos_velo(1:pop,2)./1e-9, <span class="string">'o'</span>)
    axis([0 length/1e-9 0 width/1e-9])
    title(<span class="string">'Simulation of Electrons in Silicon Crystal'</span>)
    xlabel(<span class="string">'(nm)'</span>)
    ylabel(<span class="string">'(nm)'</span>)
    subplot(3,1,2)
    <span class="comment">%Plotting the temperature of the Silicon crystal over time</span>
    plot(step*(0:j-1), temp(1:j),<span class="string">'Color'</span>,[0.1 0.1 0.1])
    axis([0 step*iter 200 400]);
    title(<span class="string">'Temperature of Electrons in Silicon Crystal'</span>)
    xlabel(<span class="string">'Time(s)'</span>)
    ylabel(<span class="string">'Temperature(K)'</span>)
    hold <span class="string">on</span>;
<span class="keyword">end</span>

<span class="comment">%Calculate the average time</span>
t_mn = ((step*iter*pop)/total_scatters);
<span class="comment">%Calculate the average velocity</span>
velocity_average= sqrt(sum((pos_velo(:,3).^2))/par + sum(pos_velo(:,4).^2)/par);
<span class="comment">%Calculate the mean free path</span>
mfp = (t_mn * velocity_average)*10^9;
<span class="comment">%Calculate the average temperature</span>
av_temp = sum(temp)/iter;
<span class="comment">%Output the average temperature</span>
fprintf(<span class="string">'Average Temperature in the Crystal for part 2 is %f K \n'</span>,av_temp)
<span class="comment">%Output the average velocity</span>
fprintf(<span class="string">'Average Electron Velocities in Silicon Crystal for part 2 are %f km/s \n'</span>,velocity_average/10^3)
<span class="comment">%Output the average time between colisions</span>
fprintf(<span class="string">'Average time for part 2 is %f ps\n'</span>,t_mn/10^-12);
<span class="comment">%Output the mean free path</span>
fprintf(<span class="string">'Mean free Path for part 2 is %f nm\n'</span>,mfp);
<span class="keyword">for</span> i = 1:pop

    <span class="comment">%Plotting the trajectory vector of each particle in the shown</span>
    <span class="comment">%population</span>
    <span class="comment">%Setting a Random colour each particle</span>
    color = [rand rand rand];
    figure(4);
    plot(traj(i,2:2:end)./10^-9, traj(i,1:2:end-1)./10^-9, <span class="string">'.'</span>, <span class="string">'Color'</span>,color)
    axis([0 length/1e-9 0 width/1e-9])
    title(<span class="string">'Trajectories of Electrons in Silicon Crystal'</span>)
    xlabel(<span class="string">'(nm)'</span>)
    ylabel(<span class="string">'(nm)'</span>)
    hold <span class="string">on</span>;
    pause(0.5)

<span class="keyword">end</span>
figure(3);
subplot(3,1,3);
<span class="comment">%Plotting Histogram of Velocities in the Silicon Crystal</span>
velocity = sqrt(pos_velo(:,3).^2 + pos_velo(:,4).^2);
histogram(velocity)
title(<span class="string">'Histogram of Electron Velocities in Silicon Crystal'</span>)
xlabel(<span class="string">'Velocity (km/s)'</span>)
ylabel(<span class="string">'Frequency'</span>)
<span class="comment">%%Question 3</span>
<span class="comment">%Creating Box Parameters for boxes shown in plots</span>
x1_box1=80;
x2_box1=120;
y1_box1=0;
y2_box1=40;
x1_box2=80;
x2_box2=120;
y1_box2=60;
y2_box2=100;
<span class="comment">%Creating Box Parameters</span>
boxes = 1e-9.*[x1_box1 x2_box1 y1_box1 y2_box1; x1_box2 x2_box2 y1_box2 y2_box2];
<span class="comment">%Boxes are specular or diffusive</span>
boxes_specular = [0 1];
<span class="keyword">for</span> j = 1:par
    <span class="comment">%Creating a position, velocity vector in the x and y directions for</span>
    <span class="comment">%the number of particles in the simulation.</span>
    ang = rand*2*pi;
    pos_velo(j,:) = [length*rand width*rand random(v_boltz) random(v_boltz)];
    <span class="keyword">while</span>(in_box(pos_velo(j,1:2), boxes))
        <span class="comment">%Checking for Particles in box, when particles are in</span>
        <span class="comment">%box we will reset there x and y position to a random</span>
        <span class="comment">%value</span>
        pos_velo(j,1:2) = [length*rand width*rand];
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="keyword">for</span> j = 1:iter
    <span class="comment">%</span>
    <span class="comment">%Updating the position velocity vector at each iteration. Using step</span>
    <span class="comment">%size * position velocity vector of each particle at each iteration in</span>
    <span class="comment">%time plus the previous X and Y locations of the particle respectively.</span>
    <span class="comment">%</span>
    pos_velo(:,1:2) = pos_velo(:,1:2) + step*pos_velo(:,3:4);


    <span class="keyword">if</span> boundaries_len &amp;&amp; boundaries_width
        <span class="comment">%Left Bound Check</span>
        i = pos_velo(:,1) &gt; length;
        pos_velo(i,1) = 2*length - pos_velo(i,1) ;
        pos_velo(i,3) = -pos_velo(i,3);
        <span class="comment">%</span>
        <span class="comment">%Right Bound Check</span>
        <span class="comment">%</span>
        i = pos_velo(:,1) &lt; 0;
        pos_velo(i,1) = -pos_velo(i,1);
        pos_velo(i,3) = -pos_velo(i,3);
        <span class="comment">%</span>
        <span class="comment">%Top Bound Check</span>
        i = pos_velo(:,2) &gt; width;
        pos_velo(i,2) = 2*width - pos_velo(i,2);
        pos_velo(i,4) = -pos_velo(i,4);
        <span class="comment">%</span>
        <span class="comment">%Bottom Bound Check</span>
        i = pos_velo(:,2) &lt; 0;
        pos_velo(i,2) = -pos_velo(i,2);
        pos_velo(i,4) = -pos_velo(i,4);
        <span class="comment">%</span>
    <span class="keyword">elseif</span> boundaries_len
        <span class="comment">%Left Bound Check</span>
        i = pos_velo(:,1) &gt; length;
        pos_velo(i,1) = 2*length - pos_velo(i,1) ;
        pos_velo(i,3) = -pos_velo(i,3);
        <span class="comment">%</span>
        <span class="comment">%Right Bound Check</span>
        <span class="comment">%</span>
        i = pos_velo(:,1) &lt; 0;
        pos_velo(i,1) = -pos_velo(i,1);
        pos_velo(i,3) = -pos_velo(i,3);
        <span class="comment">%</span>
        <span class="comment">%Top Bound Check</span>
        i = pos_velo(:,2) &gt; width;
        pos_velo(i,2) =  pos_velo(i,2) - width;

        <span class="comment">%</span>
        <span class="comment">%Bottom Bound Check</span>
        i = pos_velo(:,2) &lt; 0;
        pos_velo(i,2) = -pos_velo(i,2) + width;
        <span class="comment">%</span>
    <span class="keyword">elseif</span> boundaries_width
        <span class="comment">%Left Bound Check</span>
        i = pos_velo(:,1) &gt; length;
        pos_velo(i,1) = pos_velo(i,1) - length;
        <span class="comment">%</span>
        <span class="comment">%Right Bound Check</span>
        <span class="comment">%</span>
        i = pos_velo(:,1) &lt; 0;
        pos_velo(i,1) = pos_velo(i,1) + length;
        <span class="comment">%</span>
        <span class="comment">%Top Bound Check</span>
        i = pos_velo(:,2) &gt; width;
        pos_velo(i,2) = 2*width - pos_velo(i,2);
        pos_velo(i,4) = -pos_velo(i,4);
        <span class="comment">%</span>
        <span class="comment">%Bottom Bound Check</span>
        i = pos_velo(:,2) &lt; 0;
        pos_velo(i,2) = -pos_velo(i,2);
        pos_velo(i,4) = -pos_velo(i,4);
        <span class="comment">%</span>
    <span class="keyword">else</span>
        <span class="comment">%Left Bound Check</span>
        i = pos_velo(:,1) &gt; length;
        pos_velo(i,1) = pos_velo(i,1) - length;
        <span class="comment">%</span>
        <span class="comment">%Right Bound Check</span>
        <span class="comment">%</span>
        i = pos_velo(:,1) &lt; 0;
        pos_velo(i,1) = pos_velo(i,1) + length;
        <span class="comment">%</span>
        <span class="comment">%Top Bound Check</span>
        i = pos_velo(:,2) &gt; width;
        pos_velo(i,2) =  pos_velo(i,2) - width;
        <span class="comment">%</span>
        <span class="comment">%Bottom Bound Check</span>
        i = pos_velo(:,2) &lt; 0;
        pos_velo(i,2) = -pos_velo(i,2) + width;
        <span class="comment">%</span>
    <span class="keyword">end</span>

    <span class="comment">%Creating a random number i for each particle in the population that is</span>
    <span class="comment">%the probability of this particle scattering at this time iteration</span>
    <span class="comment">%Setting i equal to a logical index array with the amount of colisions.</span>
    i= rand(pop,1) &lt; scat;
    pos_velo(i,3:4) = random(v_boltz, [sum(i),2]);
    total_scatters = total_scatters + count_scatters(i) ;

    <span class="keyword">for</span> i=1:pop
        <span class="comment">%Checking for each particle in the population to see if it has hit</span>
        <span class="comment">%a boundary of the box we created above.</span>
        box_num = in_box(pos_velo(i,1:2), boxes);
        x = 0;
        updated_x = 0;
        y = 0;
        updated_y = 0;
        <span class="keyword">while</span>(box_num ~= 0)
           <span class="comment">%If the electron come back that it has hit a boundary then we</span>
           <span class="comment">%need to see what boundary it hit in order to predict its next</span>
           <span class="comment">%move.</span>

            <span class="keyword">if</span>(pos_velo(i,3) &gt; 0)
                x = pos_velo(i,1) - boxes(box_num,1);
                updated_x = boxes(box_num,1);
            <span class="keyword">else</span>
                x = boxes(box_num,2) - pos_velo(i,1);
                updated_x = boxes(box_num,2);
            <span class="keyword">end</span>

            <span class="keyword">if</span>(pos_velo(i,4) &gt; 0)
                y = pos_velo(i,2) - boxes(box_num, 3);
                updated_y = boxes(box_num, 3);
            <span class="keyword">else</span>
                y = boxes(box_num, 4) - pos_velo(i,2);
                updated_y = boxes(box_num, 4);
            <span class="keyword">end</span>

            <span class="keyword">if</span>(x &lt; y)
                pos_velo(i,1) = updated_x;
                <span class="keyword">if</span>(~boxes_specular(box_num))
                    <span class="comment">%Diffusive Boundaries in the x direction</span>
                    change = -sign(pos_velo(i,3));
                    v = sqrt(pos_velo(i,3).^2 + pos_velo(i,4).^2);
                    angle = rand()*2*pi;
                    pos_velo(i,3) = change.*abs(v.*cos(angle));
                    pos_velo(i,4) = v.*sin(angle);
                <span class="keyword">else</span>
                    <span class="comment">% Specular Boundaries in the x direction</span>
                    pos_velo(i,3) = -pos_velo(i,3);
                <span class="keyword">end</span>
            <span class="keyword">else</span>
                pos_velo(i,2) = updated_y;
                <span class="keyword">if</span>(~boxes_specular(box_num))
                    <span class="comment">%Diffusive Boundaries in the y direction</span>
                    change = -sign(pos_velo(i,4));
                    v = sqrt(pos_velo(i,3).^2 + pos_velo(i,4).^2);
                    angle = rand()*2*pi;
                    pos_velo(i,3) = v.*cos(angle);
                    pos_velo(i,4) = change.*abs(v.*sin(angle));
                <span class="keyword">else</span>
                    <span class="comment">% Specular Boundaries in the y direction</span>
                    pos_velo(i,4) = -pos_velo(i,4);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="comment">%Getting the box that the particle is hitting</span>
            box_num = in_box(pos_velo(i,1:2), boxes);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">%Storing the Temperature value of the semiconductor at each iteration</span>
    temp(j) = (sum(pos_velo(:,3).^2) + sum(pos_velo(:,4).^2))*m/k/2/par;
    <span class="comment">%Storing the Trajectory value of the semiconductor at each iteration</span>
    traj(1:iter,2*j:2*j+1) = [pos_velo(1:iter,1) pos_velo(1:iter,2)];

    figure(5);
    subplot(2,1,1)
    <span class="comment">%Creating the box in the plot</span>
    x_plot1 = [x1_box1, x2_box1, x2_box1, x1_box1, x1_box1];
    y_plot1 = [y1_box1, y1_box1, y2_box1, y2_box1, y1_box1];
    x_plot2 = [x1_box2, x2_box2, x2_box2, x1_box2, x1_box2];
    y_plot2 = [y1_box2, y1_box2, y2_box2, y2_box2, y1_box2];
    <span class="comment">%Plotting the Boxes</span>
    plot(x_plot1,y_plot1,<span class="string">'-'</span>,<span class="string">'Color'</span>,[0 0 0])
    hold <span class="string">on</span>
    plot(x_plot2,y_plot2,<span class="string">'-'</span>,<span class="string">'Color'</span>,[0 0 0])
    <span class="comment">%Plotting each particle in the population at each time step</span>
    plot(pos_velo(1:pop,1)./10^-9, pos_velo(1:pop,2)./10^-9, <span class="string">'o'</span>)
    hold <span class="string">off</span>
    axis([0 length/1e-9 0 width/1e-9])
    title(<span class="string">'Simulation of Electrons in Silicon Crystal'</span>)
    xlabel(<span class="string">'(nm)'</span>)
    ylabel(<span class="string">'(nm)'</span>)
    subplot(2,1,2)
    <span class="comment">%Plotting the temperature of the Silicon crystal over time</span>
    plot(step*(0:j-1), temp(1:j),<span class="string">'Color'</span>,[0.1 0.1 0.1])
    axis([0 step*iter 200 400]);
    title(<span class="string">'Temperature of Electrons in Silicon Crystal'</span>)
    xlabel(<span class="string">'Time(s)'</span>)
    ylabel(<span class="string">'Temperature(K)'</span>)
    hold <span class="string">on</span>
<span class="keyword">end</span>
<span class="comment">%Creating the box in the plot</span>
x_plot1 = [x1_box1, x2_box1, x2_box1, x1_box1, x1_box1];
y_plot1 = [y1_box1, y1_box1, y2_box1, y2_box1, y1_box1];
x_plot2 = [x1_box2, x2_box2, x2_box2, x1_box2, x1_box2];
y_plot2 = [y1_box2, y1_box2, y2_box2, y2_box2, y1_box2];
figure(6)
<span class="comment">%Plotting Box</span>
plot(x_plot1,y_plot1,<span class="string">'-'</span>,<span class="string">'Color'</span>,[0 0 0])
hold <span class="string">on</span>
plot(x_plot2,y_plot2,<span class="string">'-'</span>,<span class="string">'Color'</span>,[0 0 0])
<span class="keyword">for</span> i = 1:pop
    <span class="comment">%Plotting the trajectory vector of each particle in the shown</span>
    <span class="comment">%population</span>
    <span class="comment">%Setting a Random colour each particle</span>
    color = [rand rand rand];
    figure(6)
    plot(traj(i,2:2:end)./1e-9, traj(i,1:2:end-1)./1e-9, <span class="string">'.'</span>, <span class="string">'Color'</span>,color);
    axis([0 length/1e-9 0 width/1e-9]);
    title(<span class="string">'Trajectories of Electrons in Silicon Crystal'</span>)
    xlabel(<span class="string">'(nm)'</span>)
    ylabel(<span class="string">'(nm)'</span>)
    hold <span class="string">on</span>;
    pause(0.5);

<span class="keyword">end</span>
<span class="comment">%Calculate the average time</span>
t_mn = ((step*iter*pop)/total_scatters);
<span class="comment">%Calculate the average velocity</span>
velocity_average= sqrt(sum((pos_velo(:,3).^2))/par + sum(pos_velo(:,4).^2)/par);
<span class="comment">%Calculate the mean free path</span>
mfp = (t_mn * velocity_average)*10^9;
<span class="comment">%Calculate the average temperature</span>
av_temp = sum(temp)/iter;
<span class="comment">%Output the average temperature</span>
fprintf(<span class="string">'Average Temperature in the Crystal for part 3 is %f K \n'</span>,av_temp)
<span class="comment">%Output the average velocity</span>
fprintf(<span class="string">'Average Electron Velocities in Silicon Crystal for part 3 are %f km/s \n'</span>,velocity_average/10^3)
<span class="comment">%Output the average time between colisions</span>
fprintf(<span class="string">'Average time for part 3 is %f ps\n'</span>,t_mn/10^-12);
<span class="comment">%Output the mean free path</span>
fprintf(<span class="string">'Mean free Path for part 3 is %f nm\n'</span>,mfp);
figure(7)
<span class="comment">%Creating a 3D Histogram with x and y positions</span>
electron_density = hist3([pos_velo(:,1),pos_velo(:,2)],[200 100]);
n = 20;
sigma = 4;
<span class="comment">%Performing smoothing on histogram through convolution with meshgrid</span>
[u, v] = meshgrid(round(-n./2):round(n./2),round(-n./2):round(n./2));
smooth_func = exp(-u.^2/(2*sigma^2)-v.^2/(2*sigma^2));
smooth_func = smooth_func./sum(smooth_func(:));
<span class="comment">%Performing convolution of the two matrices and plotting the convolution</span>
imagesc(conv2(electron_density,smooth_func));
title(<span class="string">'Electron Density Map in Silicon Crystal'</span>);
xlabel(<span class="string">'x (nm)'</span>);
ylabel(<span class="string">'y (nm)'</span>);


<span class="comment">%</span>
<span class="comment">% Temperature map calculations</span>
<span class="comment">%</span>
<span class="comment">%Creating a temperature sum variable for the length and width of the</span>
<span class="comment">%silicon crystal</span>
temp_sum = zeros(ceil((length)/10/10^-9), ceil((width)/10/10^-9));
<span class="comment">%Counting the temperature variables for the length and width of the</span>
<span class="comment">%silicon crystal</span>
temp_num = zeros(ceil((length)/10/10^-9), ceil((width)/10/10^-9));

<span class="keyword">for</span> i = 1:par
    <span class="comment">%</span>
    x = floor(pos_velo(i, 1)/10/10^-9);
    y = floor(pos_velo(i, 2)/10/10^-9);
    <span class="comment">%</span>
    <span class="keyword">if</span> (x==0)
        x = 1;
    <span class="keyword">end</span>
    <span class="keyword">if</span> (y==0)
        y = 1;
    <span class="keyword">end</span>
    <span class="comment">%Calculating the temperature sum for e</span>
    temp_sum(x, y) = temp_sum(x, y) + ( pos_velo(i,3)^2 + pos_velo(i, 4)^2 );
    temp_num(x, y) = temp_num(x, y) + 1;
<span class="keyword">end</span>

<span class="comment">%Calculating temperature matrix</span>
temperature_matrix = temp_sum.*(m./k./2./temp_num);
<span class="comment">%Performing convolution of the two matrices and plotting the convolution</span>
imagesc(conv2(temperature_matrix,smooth_func));
title(<span class="string">'Temperature Map of Silicon Crystal'</span>);
xlabel(<span class="string">'x (nm)'</span>);
ylabel(<span class="string">'y (nm)'</span>);


<span class="keyword">function</span> count=count_scatters(matrix)
<span class="comment">%This function creates a counter which counts the number of colisions of</span>
<span class="comment">%particles.</span>
count = 0;
<span class="keyword">for</span> i=1:size(matrix)
    <span class="keyword">if</span> matrix(i) == 1
        count=count+1;
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">function</span> box_num = in_box(pos, boxes)
<span class="comment">%Checks for Particles inside the box, when they are in the box it returns</span>
<span class="comment">%true so that the particles trajectory can be recalculated.</span>
box_num = 0;
<span class="keyword">for</span> i=1:size(boxes,1)
    <span class="keyword">if</span>(pos(1) &gt; boxes(i,1) &amp;&amp; pos(1) &lt; boxes(i,2) &amp;&amp; pos(2) &gt; boxes(i,3) &amp;&amp; pos(2) &lt; boxes(i,4))
        box_num = i;
        <span class="keyword">return</span>;
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput">Thermal Velocity for part 1 is 187.018585 km/s
Mean free path for part 1 is 37.403717 nm
Average Temperature in the Crystal for part 2 is 298.506927 K 
Average Electron Velocities in Silicon Crystal for part 2 are 186.511114 km/s 
Average time for part 2 is 0.237647 ps
Mean free Path for part 2 is 44.323845 nm
Average Temperature in the Crystal for part 3 is 301.010014 K 
Average Electron Velocities in Silicon Crystal for part 3 are 187.355092 km/s 
Average time for part 3 is 0.116240 ps
Mean free Path for part 3 is 21.778246 nm
</pre><img vspace="5" hspace="5" src="./MonteCarlo_files/MonteCarlo_01.png" alt=""> <img vspace="5" hspace="5" src="./MonteCarlo_files/MonteCarlo_02.png" alt=""> <img vspace="5" hspace="5" src="./MonteCarlo_files/MonteCarlo_03.png" alt=""> <img vspace="5" hspace="5" src="./MonteCarlo_files/MonteCarlo_04.png" alt=""> <img vspace="5" hspace="5" src="./MonteCarlo_files/MonteCarlo_05.png" alt=""> <img vspace="5" hspace="5" src="./MonteCarlo_files/MonteCarlo_06.png" alt=""> <img vspace="5" hspace="5" src="./MonteCarlo_files/MonteCarlo_07.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2019b</a><br></p></div><!--
##### SOURCE BEGIN #####
%%Adam Heffernan 100977570 Assignment 1 ELEC 4700. Completed on 2/1/2020.

clc
close all

m_0 = 9.10938e-31; %Mass of Electron
m = 0.26*m_0;%Effective mass in silicon
T = 300;%temperature in Kelvin
k = 1.38064e-23;%Boltzmans Constant
v_th = sqrt((2*k*T)/m); %Thermal velocity of particles
mean = 0.2e-12;%Mean value
width = 100e-9;%Width of Wafer
length = 200e-9;%Length of the channel
par = 10000;%Particles
pop = 10; %Mapping population
iter = 200;%Iterations
pos_velo = zeros(par,4);%Initializing position velocity Matrix
temp = zeros(iter,1);%Initializing position velocity Matrix
traj = zeros(iter, 2*pop);%Initializing trajectory Matrix
step = width/v_th/100;%Calculating step size for the movement of particles
boundaries_len = false(1); %Either diffusive or specular boundaries true for specular false for diffusive
boundaries_width = false(1);%Either diffusive or specular boundaries true for specular false for diffusive
total_scatters = 0;
%Calculating mean free path for part 1
l=v_th*mean;
%Outputting mean free path and thermal velocity for part 1
fprintf('Thermal Velocity for part 1 is %f km/s\n',v_th/10^3)
fprintf('Mean free path for part 1 is %f nm\n',l/10^-9);
%%Question 1
for j = 1:par
    %Creating a position, velocity vector in the x and y directions for
    %the number of particles in the simulation.
    ang = rand*2*pi;
    pos_velo(j,:) = [length*rand width*rand v_th*cos(ang) v_th*sin(ang)];
end

for j = 1:iter
    %Updating the position velocity vector at each iteration. Using step
    %size * position velocity vector of each particle at each iteration in
    %time plus the previous X and Y locations of the particle respectively.
    %
    pos_velo(:,1:2) = pos_velo(:,1:2) + step*pos_velo(:,3:4);
    %
    %Left Bound Check
    i = pos_velo(:,1) > length;
    pos_velo(i,1) = pos_velo(i,1) - length;
    %
    %Right Bound Check
    %
    i = pos_velo(:,1) < 0;
    pos_velo(i,1) = pos_velo(i,1) + length;
    %
    %Top Bound Check
    i = pos_velo(:,2) > width;
    pos_velo(i,2) = 2*width - pos_velo(i,2);
    pos_velo(i,4) = -pos_velo(i,4);
    %
    %Bottom Bound Check
    i = pos_velo(:,2) < 0;
    pos_velo(i,2) = -pos_velo(i,2);
    pos_velo(i,4) = -pos_velo(i,4);
    %
    %Storing the Temperature value of the semiconductor at each iteration
    temp(j) = (sum(pos_velo(:,3).^2) + sum(pos_velo(:,4).^2))*m/k/2/par;
    %Storing the Trajectory value of the semiconductor at each iteration
    traj(1:iter,2*j:2*j+1) = [pos_velo(1:iter,1) pos_velo(1:iter,2)];
    figure(1);
    subplot(2,1,1)
    %Plotting each particle in the population at each time step
    plot(pos_velo(1:pop,1)./1e-9, pos_velo(1:pop,2)./1e-9, 'o');
    axis([0 length/1e-9 0 width/1e-9]);
    title('Simulation of Electrons in Silicon Crystal')
    xlabel('(nm)')
    ylabel('(nm)')
    subplot(2,1,2)
    %Plotting the temperature of the Silicon crystal over time
    plot(step*(0:j-1), temp(1:j),'Color',[0.1 0.1 0.1]);
    axis([0 step*iter 200 400]);
    title('Temperature of Electrons in Silicon Crystal')
    xlabel('Time(s)')
    ylabel('Temperature(K)')
    hold on;
end


for i = 1:pop
    
    %Setting a Random colour each particle
    color = [rand rand rand];
    figure(2)
    %Plotting the trajectory vector of each particle in the shown
    %population
    plot(traj(i,2:2:end)./1e-9, traj(i,1:2:end-1)./1e-9, '.', 'Color',color);
    axis([0 length/1e-9 0 width/1e-9]);
    title('Trajectories of Electrons in Silicon Crystal')
    xlabel('(nm)')
    ylabel('(nm)')
    hold on;
    pause(0.5);
    
end
%%Question 2
%Calculating the probability of a scattering particle
scat = 1 - exp(-step/mean);
%Calculating a normal maxwell-boltzmann distribution
v_boltz = makedist('Normal','mu',0,'sigma',sqrt(k*T/m));

for j = 1:par
    %Creating a position, velocity vector in the x and y directions for
    %the number of particles in the simulation.
    ang = rand*2*pi;
    pos_velo(j,:) = [length*rand width*rand random(v_boltz) random(v_boltz)];
end


for j = 1:iter
    %Updating the position velocity vector at each iteration. Using step
    %size * position velocity vector of each particle at each iteration in
    %time plus the previous X and Y locations of the particle respectively.
    %
    pos_velo(:,1:2) = pos_velo(:,1:2) + step*pos_velo(:,3:4);
    %
    %Left Bound Check
    %
    i = pos_velo(:,1) > length;
    pos_velo(i,1) = pos_velo(i,1) - length;
    %
    %Right Bound Check
    %
    i = pos_velo(:,1) < 0;
    pos_velo(i,1) = pos_velo(i,1) + length;
    %
    %Top Bound check
    %
    i = pos_velo(:,2) > width;
    pos_velo(i,2) = 2*width - pos_velo(i,2);
    pos_velo(i,4) = -pos_velo(i,4);
    %
    %Bottom Bound check
    %
    i = pos_velo(:,2) < 0;
    pos_velo(i,2) = -pos_velo(i,2);
    pos_velo(i,4) = -pos_velo(i,4);
    %Creating a random number t for each particle in the population that is
    %the probability of this particle scattering at this time iteration
    t=rand(pop,1);
    %Setting i equal to a logical index array with the amount of colisions.
    i= t < scat;
    pos_velo(i,3:4) = random(v_boltz, [sum(i),2]);
    %Incrementing the total number of scattered particles
    total_scatters = total_scatters + count_scatters(i);
    %Storing the Temperature value of the semiconductor at each iteration
    temp(j) = (sum(pos_velo(:,3).^2) + sum(pos_velo(:,4).^2))*m/k/2/par;
    %Storing the Trajectory value of the semiconductor at each iteration
    traj(1:iter,2*j:2*j+1) = [pos_velo(1:iter,1) pos_velo(1:iter,2)];
    figure(3)
    subplot(3,1,1)
    %Plotting each particle in the population at each time step
    plot(pos_velo(1:pop,1)./1e-9, pos_velo(1:pop,2)./1e-9, 'o')
    axis([0 length/1e-9 0 width/1e-9])
    title('Simulation of Electrons in Silicon Crystal')
    xlabel('(nm)')
    ylabel('(nm)')
    subplot(3,1,2)
    %Plotting the temperature of the Silicon crystal over time
    plot(step*(0:j-1), temp(1:j),'Color',[0.1 0.1 0.1])
    axis([0 step*iter 200 400]);
    title('Temperature of Electrons in Silicon Crystal')
    xlabel('Time(s)')
    ylabel('Temperature(K)')
    hold on;
end

%Calculate the average time
t_mn = ((step*iter*pop)/total_scatters);
%Calculate the average velocity
velocity_average= sqrt(sum((pos_velo(:,3).^2))/par + sum(pos_velo(:,4).^2)/par);
%Calculate the mean free path
mfp = (t_mn * velocity_average)*10^9;
%Calculate the average temperature
av_temp = sum(temp)/iter;
%Output the average temperature
fprintf('Average Temperature in the Crystal for part 2 is %f K \n',av_temp)
%Output the average velocity
fprintf('Average Electron Velocities in Silicon Crystal for part 2 are %f km/s \n',velocity_average/10^3)
%Output the average time between colisions
fprintf('Average time for part 2 is %f ps\n',t_mn/10^-12);
%Output the mean free path
fprintf('Mean free Path for part 2 is %f nm\n',mfp);
for i = 1:pop
    
    %Plotting the trajectory vector of each particle in the shown
    %population
    %Setting a Random colour each particle
    color = [rand rand rand];
    figure(4);
    plot(traj(i,2:2:end)./10^-9, traj(i,1:2:end-1)./10^-9, '.', 'Color',color)
    axis([0 length/1e-9 0 width/1e-9])
    title('Trajectories of Electrons in Silicon Crystal')
    xlabel('(nm)')
    ylabel('(nm)')
    hold on;
    pause(0.5)
    
end
figure(3);
subplot(3,1,3);
%Plotting Histogram of Velocities in the Silicon Crystal
velocity = sqrt(pos_velo(:,3).^2 + pos_velo(:,4).^2);
histogram(velocity)
title('Histogram of Electron Velocities in Silicon Crystal')
xlabel('Velocity (km/s)')
ylabel('Frequency')
%%Question 3
%Creating Box Parameters for boxes shown in plots
x1_box1=80;
x2_box1=120;
y1_box1=0;
y2_box1=40;
x1_box2=80;
x2_box2=120;
y1_box2=60;
y2_box2=100;
%Creating Box Parameters
boxes = 1e-9.*[x1_box1 x2_box1 y1_box1 y2_box1; x1_box2 x2_box2 y1_box2 y2_box2];
%Boxes are specular or diffusive
boxes_specular = [0 1];
for j = 1:par
    %Creating a position, velocity vector in the x and y directions for
    %the number of particles in the simulation.
    ang = rand*2*pi;
    pos_velo(j,:) = [length*rand width*rand random(v_boltz) random(v_boltz)];
    while(in_box(pos_velo(j,1:2), boxes))
        %Checking for Particles in box, when particles are in
        %box we will reset there x and y position to a random
        %value
        pos_velo(j,1:2) = [length*rand width*rand];
    end
end


for j = 1:iter
    %
    %Updating the position velocity vector at each iteration. Using step
    %size * position velocity vector of each particle at each iteration in
    %time plus the previous X and Y locations of the particle respectively.
    %
    pos_velo(:,1:2) = pos_velo(:,1:2) + step*pos_velo(:,3:4);
    
    
    if boundaries_len && boundaries_width
        %Left Bound Check
        i = pos_velo(:,1) > length;
        pos_velo(i,1) = 2*length - pos_velo(i,1) ;
        pos_velo(i,3) = -pos_velo(i,3);
        %
        %Right Bound Check
        %
        i = pos_velo(:,1) < 0;
        pos_velo(i,1) = -pos_velo(i,1);
        pos_velo(i,3) = -pos_velo(i,3);
        %
        %Top Bound Check
        i = pos_velo(:,2) > width;
        pos_velo(i,2) = 2*width - pos_velo(i,2);
        pos_velo(i,4) = -pos_velo(i,4);
        %
        %Bottom Bound Check
        i = pos_velo(:,2) < 0;
        pos_velo(i,2) = -pos_velo(i,2);
        pos_velo(i,4) = -pos_velo(i,4);
        %
    elseif boundaries_len
        %Left Bound Check
        i = pos_velo(:,1) > length;
        pos_velo(i,1) = 2*length - pos_velo(i,1) ;
        pos_velo(i,3) = -pos_velo(i,3);
        %
        %Right Bound Check
        %
        i = pos_velo(:,1) < 0;
        pos_velo(i,1) = -pos_velo(i,1);
        pos_velo(i,3) = -pos_velo(i,3);
        %
        %Top Bound Check
        i = pos_velo(:,2) > width;
        pos_velo(i,2) =  pos_velo(i,2) - width;
        
        %
        %Bottom Bound Check
        i = pos_velo(:,2) < 0;
        pos_velo(i,2) = -pos_velo(i,2) + width;
        %
    elseif boundaries_width
        %Left Bound Check
        i = pos_velo(:,1) > length;
        pos_velo(i,1) = pos_velo(i,1) - length;
        %
        %Right Bound Check
        %
        i = pos_velo(:,1) < 0;
        pos_velo(i,1) = pos_velo(i,1) + length;
        %
        %Top Bound Check
        i = pos_velo(:,2) > width;
        pos_velo(i,2) = 2*width - pos_velo(i,2);
        pos_velo(i,4) = -pos_velo(i,4);
        %
        %Bottom Bound Check
        i = pos_velo(:,2) < 0;
        pos_velo(i,2) = -pos_velo(i,2);
        pos_velo(i,4) = -pos_velo(i,4);
        %
    else
        %Left Bound Check
        i = pos_velo(:,1) > length;
        pos_velo(i,1) = pos_velo(i,1) - length;
        %
        %Right Bound Check
        %
        i = pos_velo(:,1) < 0;
        pos_velo(i,1) = pos_velo(i,1) + length;
        %
        %Top Bound Check
        i = pos_velo(:,2) > width;
        pos_velo(i,2) =  pos_velo(i,2) - width;
        %
        %Bottom Bound Check
        i = pos_velo(:,2) < 0;
        pos_velo(i,2) = -pos_velo(i,2) + width;
        %
    end
    
    %Creating a random number i for each particle in the population that is
    %the probability of this particle scattering at this time iteration
    %Setting i equal to a logical index array with the amount of colisions.
    i= rand(pop,1) < scat;
    pos_velo(i,3:4) = random(v_boltz, [sum(i),2]);
    total_scatters = total_scatters + count_scatters(i) ;
    
    for i=1:pop
        %Checking for each particle in the population to see if it has hit
        %a boundary of the box we created above. 
        box_num = in_box(pos_velo(i,1:2), boxes);
        x = 0;
        updated_x = 0;
        y = 0;
        updated_y = 0;
        while(box_num ~= 0)
           %If the electron come back that it has hit a boundary then we
           %need to see what boundary it hit in order to predict its next
           %move.
            
            if(pos_velo(i,3) > 0)
                x = pos_velo(i,1) - boxes(box_num,1);
                updated_x = boxes(box_num,1);
            else
                x = boxes(box_num,2) - pos_velo(i,1);
                updated_x = boxes(box_num,2);
            end
            
            if(pos_velo(i,4) > 0)
                y = pos_velo(i,2) - boxes(box_num, 3);
                updated_y = boxes(box_num, 3);
            else
                y = boxes(box_num, 4) - pos_velo(i,2);
                updated_y = boxes(box_num, 4);
            end
            
            if(x < y)
                pos_velo(i,1) = updated_x;
                if(~boxes_specular(box_num))
                    %Diffusive Boundaries in the x direction
                    change = -sign(pos_velo(i,3));
                    v = sqrt(pos_velo(i,3).^2 + pos_velo(i,4).^2);
                    angle = rand()*2*pi;
                    pos_velo(i,3) = change.*abs(v.*cos(angle));
                    pos_velo(i,4) = v.*sin(angle);
                else
                    % Specular Boundaries in the x direction
                    pos_velo(i,3) = -pos_velo(i,3);
                end
            else
                pos_velo(i,2) = updated_y;
                if(~boxes_specular(box_num))
                    %Diffusive Boundaries in the y direction
                    change = -sign(pos_velo(i,4));
                    v = sqrt(pos_velo(i,3).^2 + pos_velo(i,4).^2);
                    angle = rand()*2*pi;
                    pos_velo(i,3) = v.*cos(angle);
                    pos_velo(i,4) = change.*abs(v.*sin(angle));
                else
                    % Specular Boundaries in the y direction
                    pos_velo(i,4) = -pos_velo(i,4);
                end
            end
            %Getting the box that the particle is hitting
            box_num = in_box(pos_velo(i,1:2), boxes);
        end
    end
    %Storing the Temperature value of the semiconductor at each iteration
    temp(j) = (sum(pos_velo(:,3).^2) + sum(pos_velo(:,4).^2))*m/k/2/par;
    %Storing the Trajectory value of the semiconductor at each iteration
    traj(1:iter,2*j:2*j+1) = [pos_velo(1:iter,1) pos_velo(1:iter,2)];
    
    figure(5);
    subplot(2,1,1)
    %Creating the box in the plot
    x_plot1 = [x1_box1, x2_box1, x2_box1, x1_box1, x1_box1];
    y_plot1 = [y1_box1, y1_box1, y2_box1, y2_box1, y1_box1];
    x_plot2 = [x1_box2, x2_box2, x2_box2, x1_box2, x1_box2];
    y_plot2 = [y1_box2, y1_box2, y2_box2, y2_box2, y1_box2];
    %Plotting the Boxes
    plot(x_plot1,y_plot1,'-','Color',[0 0 0])
    hold on
    plot(x_plot2,y_plot2,'-','Color',[0 0 0])
    %Plotting each particle in the population at each time step
    plot(pos_velo(1:pop,1)./10^-9, pos_velo(1:pop,2)./10^-9, 'o')
    hold off
    axis([0 length/1e-9 0 width/1e-9])
    title('Simulation of Electrons in Silicon Crystal')
    xlabel('(nm)')
    ylabel('(nm)')
    subplot(2,1,2)
    %Plotting the temperature of the Silicon crystal over time
    plot(step*(0:j-1), temp(1:j),'Color',[0.1 0.1 0.1])
    axis([0 step*iter 200 400]);
    title('Temperature of Electrons in Silicon Crystal')
    xlabel('Time(s)')
    ylabel('Temperature(K)')
    hold on
end
%Creating the box in the plot
x_plot1 = [x1_box1, x2_box1, x2_box1, x1_box1, x1_box1];
y_plot1 = [y1_box1, y1_box1, y2_box1, y2_box1, y1_box1];
x_plot2 = [x1_box2, x2_box2, x2_box2, x1_box2, x1_box2];
y_plot2 = [y1_box2, y1_box2, y2_box2, y2_box2, y1_box2];
figure(6)
%Plotting Box
plot(x_plot1,y_plot1,'-','Color',[0 0 0])
hold on
plot(x_plot2,y_plot2,'-','Color',[0 0 0])
for i = 1:pop
    %Plotting the trajectory vector of each particle in the shown
    %population
    %Setting a Random colour each particle
    color = [rand rand rand];
    figure(6)
    plot(traj(i,2:2:end)./1e-9, traj(i,1:2:end-1)./1e-9, '.', 'Color',color);
    axis([0 length/1e-9 0 width/1e-9]);
    title('Trajectories of Electrons in Silicon Crystal')
    xlabel('(nm)')
    ylabel('(nm)')
    hold on;
    pause(0.5);
    
end
%Calculate the average time
t_mn = ((step*iter*pop)/total_scatters);
%Calculate the average velocity
velocity_average= sqrt(sum((pos_velo(:,3).^2))/par + sum(pos_velo(:,4).^2)/par);
%Calculate the mean free path
mfp = (t_mn * velocity_average)*10^9;
%Calculate the average temperature
av_temp = sum(temp)/iter;
%Output the average temperature
fprintf('Average Temperature in the Crystal for part 3 is %f K \n',av_temp)
%Output the average velocity
fprintf('Average Electron Velocities in Silicon Crystal for part 3 are %f km/s \n',velocity_average/10^3)
%Output the average time between colisions
fprintf('Average time for part 3 is %f ps\n',t_mn/10^-12);
%Output the mean free path
fprintf('Mean free Path for part 3 is %f nm\n',mfp);
figure(7)
%Creating a 3D Histogram with x and y positions
electron_density = hist3([pos_velo(:,1),pos_velo(:,2)],[200 100]);
n = 20;
sigma = 4;
%Performing smoothing on histogram through convolution with meshgrid
[u, v] = meshgrid(round(-n./2):round(n./2),round(-n./2):round(n./2));
smooth_func = exp(-u.^2/(2*sigma^2)-v.^2/(2*sigma^2));
smooth_func = smooth_func./sum(smooth_func(:));
%Performing convolution of the two matrices and plotting the convolution
imagesc(conv2(electron_density,smooth_func));
title('Electron Density Map in Silicon Crystal');
xlabel('x (nm)');
ylabel('y (nm)');


%
% Temperature map calculations
% 
%Creating a temperature sum variable for the length and width of the
%silicon crystal
temp_sum = zeros(ceil((length)/10/10^-9), ceil((width)/10/10^-9));
%Counting the temperature variables for the length and width of the
%silicon crystal
temp_num = zeros(ceil((length)/10/10^-9), ceil((width)/10/10^-9));

for i = 1:par
    %
    x = floor(pos_velo(i, 1)/10/10^-9);
    y = floor(pos_velo(i, 2)/10/10^-9);
    %
    if (x==0)
        x = 1;
    end
    if (y==0)
        y = 1;
    end
    %Calculating the temperature sum for e
    temp_sum(x, y) = temp_sum(x, y) + ( pos_velo(i,3)^2 + pos_velo(i, 4)^2 );
    temp_num(x, y) = temp_num(x, y) + 1;
end

%Calculating temperature matrix
temperature_matrix = temp_sum.*(m./k./2./temp_num);
%Performing convolution of the two matrices and plotting the convolution
imagesc(conv2(temperature_matrix,smooth_func));
title('Temperature Map of Silicon Crystal');
xlabel('x (nm)');
ylabel('y (nm)');


function count=count_scatters(matrix)
%This function creates a counter which counts the number of colisions of
%particles.
count = 0;
for i=1:size(matrix)
    if matrix(i) == 1
        count=count+1;
    end
end
end
function box_num = in_box(pos, boxes)
%Checks for Particles inside the box, when they are in the box it returns
%true so that the particles trajectory can be recalculated.
box_num = 0;
for i=1:size(boxes,1)
    if(pos(1) > boxes(i,1) && pos(1) < boxes(i,2) && pos(2) > boxes(i,3) && pos(2) < boxes(i,4))
        box_num = i;
        return;
    end
end
end
##### SOURCE END #####
--></body></html>